package com.tirion.db.store.builder.stats.analyzer.range;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import com.tirion.common.sequence.array.Array;
import com.tirion.common.type.Type;
import com.tirion.db.store.builder.stats.model.range.Comparators;
import com.tirion.db.store.builder.stats.model.range.${largeTypeName}Range;
import com.tirion.db.store.builder.stats.model.range.Range;
import com.tirion.db.store.builder.stats.model.range.Ranges;

/**
 * This class was autogenerated. Do not edit manually.
 */
public final class ${largeTypeName}RangeAnalyzer extends AbstractRangeAnalyzer {

	public ${largeTypeName}RangeAnalyzer(RangesConf conf) {
		super(conf);
	}

	@Override
	public Ranges analyze(Array array) {
		List<${largeTypeName}Range> ranges = new ArrayList<${largeTypeName}Range>();
		${smallTypeName}[] input = cloneAndSortArray((${smallTypeName}[])array.getUnderlying());
		int index = 1;
		while(true) {
			if(index == input.length) {
				break;
			}
			${smallTypeName} start = input[index - 1];
			${smallTypeName} end = input[index];
			if(shouldIncludeSkipRange(start, end)) {
				ranges.add(new ${largeTypeName}Range(start, end));
			}
			++index;
		}
		if(ranges.isEmpty()) {
			return null;
		}
		Ranges result = new Ranges(Type.${capsTypeName});
		for(Range range : tuneSkipRanges(ranges)) {
			result.append(range);
		}
		return result;
	}
	
	private List<${largeTypeName}Range> tuneSkipRanges(List<${largeTypeName}Range> ranges) {
		if(ranges.size() <= getMaxSkipRangesPerPage()) {
			return ranges;
		}
		Collections.sort(ranges, new Comparators.${largeTypeName}RangeComparator());
		int count = Math.min(getMaxSkipRangesPerPage(), ranges.size());
		List<${largeTypeName}Range> result = new ArrayList<${largeTypeName}Range>();
		for (int i = ranges.size() - 1; i >= ranges.size() - count; i--) {
			result.add(ranges.get(i));
		}
		return result;
	}
	
	private boolean shouldIncludeSkipRange(${smallTypeName} start, ${smallTypeName} end) {
		return (end - start - 1) >= 
		#if($smallTypeName.contains("float") || $smallTypeName.contains("double")) 
			getSkipRangeRealThreshold();
		#else		
			getSkipRangeDiscreteThreshold();
		#end
	}
	
	private ${smallTypeName}[] cloneAndSortArray(${smallTypeName}[] input) {
		${smallTypeName}[] clone = new ${smallTypeName}[input.length];
		System.arraycopy(input, 0, clone, 0, input.length);
		Arrays.sort(clone);
		return clone;
	}
}
