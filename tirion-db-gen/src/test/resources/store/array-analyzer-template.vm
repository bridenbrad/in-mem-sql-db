package com.naxx.db.store.loader.stats;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.naxx.common.array.Array;
import com.naxx.common.type.Type;
import com.naxx.db.store.page.Stats;
import com.naxx.db.store.bitmap.Bitmap;
import com.naxx.db.store.loader.stats.minmax.${largeTypeName}MinMax;
import com.naxx.db.store.loader.stats.minmax.MinMax;
import com.naxx.db.store.loader.stats.range.Comparators.${largeTypeName}RangeComparator;
import com.naxx.db.store.loader.stats.range.${largeTypeName}Range;
import com.naxx.db.store.loader.stats.range.Ranges;

/**
 * This class was autogenerated. Do not edit manually.
 */
public final class ${largeTypeName}Analyzer extends AbstractAnalyzer {

	@Override
	public List<Stats> analyze(com.naxx.common.array.Arrays arrays) {
		List<Stats> result = new ArrayList<Stats>(arrays.size());
		for(Array array : arrays.get()) {
			result.add(analyze(array));
		}
		return result;
	}

	@Override
	public Stats analyze(Array array) {
		return analyzeInternal((${smallTypeName}[])array.getUnderlying(), array.getNullBitmap());
	}

	private Stats analyzeInternal(${smallTypeName}[] input, Bitmap nullBitmap) {
		MinMax mm = null;
		if(isMinMaxOn()) {			
			${smallTypeName} min = ${largeTypeName}.MAX_VALUE;
			${smallTypeName} max = ${largeTypeName}.MIN_VALUE;
			for (int i = 0; i < input.length; i++) {
				if(nullBitmap != null && nullBitmap.isSet(i)) {					
					continue;
				}
				${smallTypeName} value = input[i];			
				min = #if($smallTypeName.contains("byte")) (byte) #end 
				  	  #if($smallTypeName.contains("short")) (short) #end Math.min(value, min);
				max = #if($smallTypeName.contains("byte")) (byte) #end 
				 	  #if($smallTypeName.contains("short")) (short) #end Math.max(value, max);
			}	
			mm = new ${largeTypeName}MinMax(min, max);
		}
		
		Set<${largeTypeName}> set = null;
		if(isDistinctOn()) {
			set = new HashSet<${largeTypeName}>();
			for (int i = 0; i < input.length; i++) {
				if(nullBitmap != null && nullBitmap.isSet(i)) {					
					continue;
				}
				${smallTypeName} value = input[i];			
				set.add(value);
			}	
			if(nullBitmap != null) {
				set.add(null);
			}
		}
		
		Ranges ranges = null;
		if(isSkipRangesOn()) {
			ranges = buildRanges(input);
		}
		return new Stats(set != null ? set.size() : -1, mm, ranges);
	}
	
	private Ranges buildRanges(${smallTypeName}[] input) {
		List<${largeTypeName}Range> ranges = new ArrayList<${largeTypeName}Range>();
		${smallTypeName}[] array = cloneArray(input); // we must not sort input array
		Arrays.sort(array);
		int index = 1;
		while(true) {
			if(index == array.length) {
				break;
			}
			${smallTypeName} start = array[index - 1];
			${smallTypeName} end = array[index];
			if(shouldIncludeSkipRange(start, end)) {
				ranges.add(new ${largeTypeName}Range(start, end));
			}
			++index;
		}
		if(ranges.isEmpty()) {
			return null;
		}
		ranges = tuneSkipRanges(ranges);
		Ranges result = new Ranges(Type.${capsTypeName});
		result.append(ranges);
		return result;
	}
	
	private boolean shouldIncludeSkipRange(${smallTypeName} start, ${smallTypeName} end) {
		return (end - start -1) >= 
		#if($smallTypeName.contains("float") || $smallTypeName.contains("double")) 
			getSkipRangeRealThreshold();
		#else		
			getSkipRangeDiscreteThreshold();
		#end 
	}
	
	private List<${largeTypeName}Range> tuneSkipRanges(List<${largeTypeName}Range> ranges) {
		if(ranges.size() <= getMaxSkipRangesPerPage()) {
			return ranges;
		}
		Collections.sort(ranges, new ${largeTypeName}RangeComparator());
		int count = Math.min(getMaxSkipRangesPerPage(), ranges.size());
		List<${largeTypeName}Range> result = new ArrayList<${largeTypeName}Range>();
		for (int i = ranges.size() - 1; i >= ranges.size() - count; i--) {
			result.add(ranges.get(i));
		}
		return result;
	}
	
	private ${smallTypeName}[] cloneArray(${smallTypeName}[] input) {
		${smallTypeName}[] clone = new ${smallTypeName}[input.length];
		System.arraycopy(input, 0, clone, 0, input.length);
		return clone;
	}
}